// Code generated by protoc-gen-go. DO NOT EDIT.
// source: orc8r/cloud/go/services/certifier/protos/certifier.proto

package protos

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protos "magma/orc8r/lib/go/protos"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Effect int32

const (
	Effect_UNKNOWN Effect = 0
	Effect_DENY    Effect = 1
	Effect_ALLOW   Effect = 2
)

var Effect_name = map[int32]string{
	0: "UNKNOWN",
	1: "DENY",
	2: "ALLOW",
}

var Effect_value = map[string]int32{
	"UNKNOWN": 0,
	"DENY":    1,
	"ALLOW":   2,
}

func (x Effect) String() string {
	return proto.EnumName(Effect_name, int32(x))
}

func (Effect) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0037205171c15011, []int{0}
}

type Action int32

const (
	Action_NONE  Action = 0
	Action_READ  Action = 1
	Action_WRITE Action = 2
)

var Action_name = map[int32]string{
	0: "NONE",
	1: "READ",
	2: "WRITE",
}

var Action_value = map[string]int32{
	"NONE":  0,
	"READ":  1,
	"WRITE": 2,
}

func (x Action) String() string {
	return proto.EnumName(Action_name, int32(x))
}

func (Action) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0037205171c15011, []int{1}
}

type CertificateInfo struct {
	Id                   *protos.Identity     `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	NotBefore            *timestamp.Timestamp `protobuf:"bytes,2,opt,name=not_before,json=notBefore,proto3" json:"not_before,omitempty"`
	NotAfter             *timestamp.Timestamp `protobuf:"bytes,3,opt,name=not_after,json=notAfter,proto3" json:"not_after,omitempty"`
	CertType             protos.CertType      `protobuf:"varint,4,opt,name=cert_type,json=certType,proto3,enum=magma.orc8r.CertType" json:"cert_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *CertificateInfo) Reset()         { *m = CertificateInfo{} }
func (m *CertificateInfo) String() string { return proto.CompactTextString(m) }
func (*CertificateInfo) ProtoMessage()    {}
func (*CertificateInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0037205171c15011, []int{0}
}

func (m *CertificateInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CertificateInfo.Unmarshal(m, b)
}
func (m *CertificateInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CertificateInfo.Marshal(b, m, deterministic)
}
func (m *CertificateInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificateInfo.Merge(m, src)
}
func (m *CertificateInfo) XXX_Size() int {
	return xxx_messageInfo_CertificateInfo.Size(m)
}
func (m *CertificateInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificateInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CertificateInfo proto.InternalMessageInfo

func (m *CertificateInfo) GetId() *protos.Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *CertificateInfo) GetNotBefore() *timestamp.Timestamp {
	if m != nil {
		return m.NotBefore
	}
	return nil
}

func (m *CertificateInfo) GetNotAfter() *timestamp.Timestamp {
	if m != nil {
		return m.NotAfter
	}
	return nil
}

func (m *CertificateInfo) GetCertType() protos.CertType {
	if m != nil {
		return m.CertType
	}
	return protos.CertType_DEFAULT
}

type CertificateInfoMap struct {
	Certificates         map[string]*CertificateInfo `protobuf:"bytes,1,rep,name=certificates,proto3" json:"certificates,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *CertificateInfoMap) Reset()         { *m = CertificateInfoMap{} }
func (m *CertificateInfoMap) String() string { return proto.CompactTextString(m) }
func (*CertificateInfoMap) ProtoMessage()    {}
func (*CertificateInfoMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_0037205171c15011, []int{1}
}

func (m *CertificateInfoMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CertificateInfoMap.Unmarshal(m, b)
}
func (m *CertificateInfoMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CertificateInfoMap.Marshal(b, m, deterministic)
}
func (m *CertificateInfoMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificateInfoMap.Merge(m, src)
}
func (m *CertificateInfoMap) XXX_Size() int {
	return xxx_messageInfo_CertificateInfoMap.Size(m)
}
func (m *CertificateInfoMap) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificateInfoMap.DiscardUnknown(m)
}

var xxx_messageInfo_CertificateInfoMap proto.InternalMessageInfo

func (m *CertificateInfoMap) GetCertificates() map[string]*CertificateInfo {
	if m != nil {
		return m.Certificates
	}
	return nil
}

type AddCertRequest struct {
	Id                   *protos.Identity `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	CertDer              []byte           `protobuf:"bytes,2,opt,name=cert_der,json=certDer,proto3" json:"cert_der,omitempty"`
	CertType             protos.CertType  `protobuf:"varint,3,opt,name=cert_type,json=certType,proto3,enum=magma.orc8r.CertType" json:"cert_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *AddCertRequest) Reset()         { *m = AddCertRequest{} }
func (m *AddCertRequest) String() string { return proto.CompactTextString(m) }
func (*AddCertRequest) ProtoMessage()    {}
func (*AddCertRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0037205171c15011, []int{2}
}

func (m *AddCertRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AddCertRequest.Unmarshal(m, b)
}
func (m *AddCertRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AddCertRequest.Marshal(b, m, deterministic)
}
func (m *AddCertRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddCertRequest.Merge(m, src)
}
func (m *AddCertRequest) XXX_Size() int {
	return xxx_messageInfo_AddCertRequest.Size(m)
}
func (m *AddCertRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddCertRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddCertRequest proto.InternalMessageInfo

func (m *AddCertRequest) GetId() *protos.Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *AddCertRequest) GetCertDer() []byte {
	if m != nil {
		return m.CertDer
	}
	return nil
}

func (m *AddCertRequest) GetCertType() protos.CertType {
	if m != nil {
		return m.CertType
	}
	return protos.CertType_DEFAULT
}

type SerialNumbers struct {
	Sns                  []string `protobuf:"bytes,1,rep,name=sns,proto3" json:"sns,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SerialNumbers) Reset()         { *m = SerialNumbers{} }
func (m *SerialNumbers) String() string { return proto.CompactTextString(m) }
func (*SerialNumbers) ProtoMessage()    {}
func (*SerialNumbers) Descriptor() ([]byte, []int) {
	return fileDescriptor_0037205171c15011, []int{3}
}

func (m *SerialNumbers) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SerialNumbers.Unmarshal(m, b)
}
func (m *SerialNumbers) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SerialNumbers.Marshal(b, m, deterministic)
}
func (m *SerialNumbers) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SerialNumbers.Merge(m, src)
}
func (m *SerialNumbers) XXX_Size() int {
	return xxx_messageInfo_SerialNumbers.Size(m)
}
func (m *SerialNumbers) XXX_DiscardUnknown() {
	xxx_messageInfo_SerialNumbers.DiscardUnknown(m)
}

var xxx_messageInfo_SerialNumbers proto.InternalMessageInfo

func (m *SerialNumbers) GetSns() []string {
	if m != nil {
		return m.Sns
	}
	return nil
}

type GetCARequest struct {
	CertType             protos.CertType `protobuf:"varint,1,opt,name=cert_type,json=certType,proto3,enum=magma.orc8r.CertType" json:"cert_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GetCARequest) Reset()         { *m = GetCARequest{} }
func (m *GetCARequest) String() string { return proto.CompactTextString(m) }
func (*GetCARequest) ProtoMessage()    {}
func (*GetCARequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0037205171c15011, []int{4}
}

func (m *GetCARequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetCARequest.Unmarshal(m, b)
}
func (m *GetCARequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetCARequest.Marshal(b, m, deterministic)
}
func (m *GetCARequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCARequest.Merge(m, src)
}
func (m *GetCARequest) XXX_Size() int {
	return xxx_messageInfo_GetCARequest.Size(m)
}
func (m *GetCARequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCARequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetCARequest proto.InternalMessageInfo

func (m *GetCARequest) GetCertType() protos.CertType {
	if m != nil {
		return m.CertType
	}
	return protos.CertType_DEFAULT
}

type Operator struct {
	Username             string              `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	Password             []byte              `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	Tokens               *Operator_TokenList `protobuf:"bytes,3,opt,name=tokens,proto3" json:"tokens,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Operator) Reset()         { *m = Operator{} }
func (m *Operator) String() string { return proto.CompactTextString(m) }
func (*Operator) ProtoMessage()    {}
func (*Operator) Descriptor() ([]byte, []int) {
	return fileDescriptor_0037205171c15011, []int{5}
}

func (m *Operator) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Operator.Unmarshal(m, b)
}
func (m *Operator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Operator.Marshal(b, m, deterministic)
}
func (m *Operator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Operator.Merge(m, src)
}
func (m *Operator) XXX_Size() int {
	return xxx_messageInfo_Operator.Size(m)
}
func (m *Operator) XXX_DiscardUnknown() {
	xxx_messageInfo_Operator.DiscardUnknown(m)
}

var xxx_messageInfo_Operator proto.InternalMessageInfo

func (m *Operator) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Operator) GetPassword() []byte {
	if m != nil {
		return m.Password
	}
	return nil
}

func (m *Operator) GetTokens() *Operator_TokenList {
	if m != nil {
		return m.Tokens
	}
	return nil
}

type Operator_TokenList struct {
	Token                []string `protobuf:"bytes,1,rep,name=token,proto3" json:"token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Operator_TokenList) Reset()         { *m = Operator_TokenList{} }
func (m *Operator_TokenList) String() string { return proto.CompactTextString(m) }
func (*Operator_TokenList) ProtoMessage()    {}
func (*Operator_TokenList) Descriptor() ([]byte, []int) {
	return fileDescriptor_0037205171c15011, []int{5, 0}
}

func (m *Operator_TokenList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Operator_TokenList.Unmarshal(m, b)
}
func (m *Operator_TokenList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Operator_TokenList.Marshal(b, m, deterministic)
}
func (m *Operator_TokenList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Operator_TokenList.Merge(m, src)
}
func (m *Operator_TokenList) XXX_Size() int {
	return xxx_messageInfo_Operator_TokenList.Size(m)
}
func (m *Operator_TokenList) XXX_DiscardUnknown() {
	xxx_messageInfo_Operator_TokenList.DiscardUnknown(m)
}

var xxx_messageInfo_Operator_TokenList proto.InternalMessageInfo

func (m *Operator_TokenList) GetToken() []string {
	if m != nil {
		return m.Token
	}
	return nil
}

type Policy struct {
	Token                string               `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	Effect               Effect               `protobuf:"varint,2,opt,name=effect,proto3,enum=magma.orc8r.certifier.Effect" json:"effect,omitempty"`
	Action               Action               `protobuf:"varint,3,opt,name=action,proto3,enum=magma.orc8r.certifier.Action" json:"action,omitempty"`
	Resources            *Policy_ResourceList `protobuf:"bytes,4,opt,name=resources,proto3" json:"resources,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Policy) Reset()         { *m = Policy{} }
func (m *Policy) String() string { return proto.CompactTextString(m) }
func (*Policy) ProtoMessage()    {}
func (*Policy) Descriptor() ([]byte, []int) {
	return fileDescriptor_0037205171c15011, []int{6}
}

func (m *Policy) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Policy.Unmarshal(m, b)
}
func (m *Policy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Policy.Marshal(b, m, deterministic)
}
func (m *Policy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Policy.Merge(m, src)
}
func (m *Policy) XXX_Size() int {
	return xxx_messageInfo_Policy.Size(m)
}
func (m *Policy) XXX_DiscardUnknown() {
	xxx_messageInfo_Policy.DiscardUnknown(m)
}

var xxx_messageInfo_Policy proto.InternalMessageInfo

func (m *Policy) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *Policy) GetEffect() Effect {
	if m != nil {
		return m.Effect
	}
	return Effect_UNKNOWN
}

func (m *Policy) GetAction() Action {
	if m != nil {
		return m.Action
	}
	return Action_NONE
}

func (m *Policy) GetResources() *Policy_ResourceList {
	if m != nil {
		return m.Resources
	}
	return nil
}

type Policy_ResourceList struct {
	Resource             []string `protobuf:"bytes,4,rep,name=resource,proto3" json:"resource,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Policy_ResourceList) Reset()         { *m = Policy_ResourceList{} }
func (m *Policy_ResourceList) String() string { return proto.CompactTextString(m) }
func (*Policy_ResourceList) ProtoMessage()    {}
func (*Policy_ResourceList) Descriptor() ([]byte, []int) {
	return fileDescriptor_0037205171c15011, []int{6, 0}
}

func (m *Policy_ResourceList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Policy_ResourceList.Unmarshal(m, b)
}
func (m *Policy_ResourceList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Policy_ResourceList.Marshal(b, m, deterministic)
}
func (m *Policy_ResourceList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Policy_ResourceList.Merge(m, src)
}
func (m *Policy_ResourceList) XXX_Size() int {
	return xxx_messageInfo_Policy_ResourceList.Size(m)
}
func (m *Policy_ResourceList) XXX_DiscardUnknown() {
	xxx_messageInfo_Policy_ResourceList.DiscardUnknown(m)
}

var xxx_messageInfo_Policy_ResourceList proto.InternalMessageInfo

func (m *Policy_ResourceList) GetResource() []string {
	if m != nil {
		return m.Resource
	}
	return nil
}

type GetOperatorRequest struct {
	Username             string   `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetOperatorRequest) Reset()         { *m = GetOperatorRequest{} }
func (m *GetOperatorRequest) String() string { return proto.CompactTextString(m) }
func (*GetOperatorRequest) ProtoMessage()    {}
func (*GetOperatorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0037205171c15011, []int{7}
}

func (m *GetOperatorRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetOperatorRequest.Unmarshal(m, b)
}
func (m *GetOperatorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetOperatorRequest.Marshal(b, m, deterministic)
}
func (m *GetOperatorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetOperatorRequest.Merge(m, src)
}
func (m *GetOperatorRequest) XXX_Size() int {
	return xxx_messageInfo_GetOperatorRequest.Size(m)
}
func (m *GetOperatorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetOperatorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetOperatorRequest proto.InternalMessageInfo

func (m *GetOperatorRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *GetOperatorRequest) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type CreateUserRequest struct {
	User                 *Operator `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	Policy               *Policy   `protobuf:"bytes,2,opt,name=policy,proto3" json:"policy,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *CreateUserRequest) Reset()         { *m = CreateUserRequest{} }
func (m *CreateUserRequest) String() string { return proto.CompactTextString(m) }
func (*CreateUserRequest) ProtoMessage()    {}
func (*CreateUserRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0037205171c15011, []int{8}
}

func (m *CreateUserRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateUserRequest.Unmarshal(m, b)
}
func (m *CreateUserRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateUserRequest.Marshal(b, m, deterministic)
}
func (m *CreateUserRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateUserRequest.Merge(m, src)
}
func (m *CreateUserRequest) XXX_Size() int {
	return xxx_messageInfo_CreateUserRequest.Size(m)
}
func (m *CreateUserRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateUserRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateUserRequest proto.InternalMessageInfo

func (m *CreateUserRequest) GetUser() *Operator {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *CreateUserRequest) GetPolicy() *Policy {
	if m != nil {
		return m.Policy
	}
	return nil
}

type GetPolicyDecisionRequest struct {
	TokenList            *Operator_TokenList `protobuf:"bytes,1,opt,name=tokenList,proto3" json:"tokenList,omitempty"`
	RequestAction        Action              `protobuf:"varint,2,opt,name=requestAction,proto3,enum=magma.orc8r.certifier.Action" json:"requestAction,omitempty"`
	Resource             string              `protobuf:"bytes,3,opt,name=resource,proto3" json:"resource,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *GetPolicyDecisionRequest) Reset()         { *m = GetPolicyDecisionRequest{} }
func (m *GetPolicyDecisionRequest) String() string { return proto.CompactTextString(m) }
func (*GetPolicyDecisionRequest) ProtoMessage()    {}
func (*GetPolicyDecisionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0037205171c15011, []int{9}
}

func (m *GetPolicyDecisionRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetPolicyDecisionRequest.Unmarshal(m, b)
}
func (m *GetPolicyDecisionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetPolicyDecisionRequest.Marshal(b, m, deterministic)
}
func (m *GetPolicyDecisionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPolicyDecisionRequest.Merge(m, src)
}
func (m *GetPolicyDecisionRequest) XXX_Size() int {
	return xxx_messageInfo_GetPolicyDecisionRequest.Size(m)
}
func (m *GetPolicyDecisionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPolicyDecisionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetPolicyDecisionRequest proto.InternalMessageInfo

func (m *GetPolicyDecisionRequest) GetTokenList() *Operator_TokenList {
	if m != nil {
		return m.TokenList
	}
	return nil
}

func (m *GetPolicyDecisionRequest) GetRequestAction() Action {
	if m != nil {
		return m.RequestAction
	}
	return Action_NONE
}

func (m *GetPolicyDecisionRequest) GetResource() string {
	if m != nil {
		return m.Resource
	}
	return ""
}

type PolicyDecision struct {
	Effect               Effect   `protobuf:"varint,1,opt,name=effect,proto3,enum=magma.orc8r.certifier.Effect" json:"effect,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PolicyDecision) Reset()         { *m = PolicyDecision{} }
func (m *PolicyDecision) String() string { return proto.CompactTextString(m) }
func (*PolicyDecision) ProtoMessage()    {}
func (*PolicyDecision) Descriptor() ([]byte, []int) {
	return fileDescriptor_0037205171c15011, []int{10}
}

func (m *PolicyDecision) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PolicyDecision.Unmarshal(m, b)
}
func (m *PolicyDecision) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PolicyDecision.Marshal(b, m, deterministic)
}
func (m *PolicyDecision) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyDecision.Merge(m, src)
}
func (m *PolicyDecision) XXX_Size() int {
	return xxx_messageInfo_PolicyDecision.Size(m)
}
func (m *PolicyDecision) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyDecision.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyDecision proto.InternalMessageInfo

func (m *PolicyDecision) GetEffect() Effect {
	if m != nil {
		return m.Effect
	}
	return Effect_UNKNOWN
}

func init() {
	proto.RegisterEnum("magma.orc8r.certifier.Effect", Effect_name, Effect_value)
	proto.RegisterEnum("magma.orc8r.certifier.Action", Action_name, Action_value)
	proto.RegisterType((*CertificateInfo)(nil), "magma.orc8r.certifier.CertificateInfo")
	proto.RegisterType((*CertificateInfoMap)(nil), "magma.orc8r.certifier.CertificateInfoMap")
	proto.RegisterMapType((map[string]*CertificateInfo)(nil), "magma.orc8r.certifier.CertificateInfoMap.CertificatesEntry")
	proto.RegisterType((*AddCertRequest)(nil), "magma.orc8r.certifier.AddCertRequest")
	proto.RegisterType((*SerialNumbers)(nil), "magma.orc8r.certifier.SerialNumbers")
	proto.RegisterType((*GetCARequest)(nil), "magma.orc8r.certifier.GetCARequest")
	proto.RegisterType((*Operator)(nil), "magma.orc8r.certifier.Operator")
	proto.RegisterType((*Operator_TokenList)(nil), "magma.orc8r.certifier.Operator.TokenList")
	proto.RegisterType((*Policy)(nil), "magma.orc8r.certifier.Policy")
	proto.RegisterType((*Policy_ResourceList)(nil), "magma.orc8r.certifier.Policy.ResourceList")
	proto.RegisterType((*GetOperatorRequest)(nil), "magma.orc8r.certifier.GetOperatorRequest")
	proto.RegisterType((*CreateUserRequest)(nil), "magma.orc8r.certifier.CreateUserRequest")
	proto.RegisterType((*GetPolicyDecisionRequest)(nil), "magma.orc8r.certifier.GetPolicyDecisionRequest")
	proto.RegisterType((*PolicyDecision)(nil), "magma.orc8r.certifier.PolicyDecision")
}

func init() {
	proto.RegisterFile("orc8r/cloud/go/services/certifier/protos/certifier.proto", fileDescriptor_0037205171c15011)
}

var fileDescriptor_0037205171c15011 = []byte{
	// 1002 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0x5f, 0x6f, 0xe2, 0x46,
	0x10, 0xc7, 0x40, 0x08, 0x0c, 0x39, 0x0a, 0xdb, 0x9e, 0xc4, 0xf9, 0x7a, 0xba, 0x9c, 0xdb, 0xb4,
	0x09, 0x0f, 0xa6, 0xe2, 0x54, 0x35, 0xfd, 0xf3, 0x42, 0x08, 0xc7, 0x45, 0xcd, 0x91, 0xd6, 0xe1,
	0x1a, 0xb5, 0x2f, 0xc8, 0x98, 0x01, 0x59, 0x01, 0x2f, 0xdd, 0x5d, 0x52, 0xf1, 0x54, 0xa9, 0x0f,
	0xfd, 0x2c, 0xfd, 0x20, 0xfd, 0x1c, 0x55, 0x9f, 0xfa, 0x39, 0x2a, 0xaf, 0xd7, 0x8e, 0x4d, 0x70,
	0x42, 0x9e, 0xf0, 0xce, 0xfc, 0xe6, 0xdf, 0x6f, 0x66, 0x67, 0x81, 0x63, 0xca, 0x9c, 0x63, 0xd6,
	0x74, 0x66, 0x74, 0x39, 0x6e, 0x4e, 0x69, 0x93, 0x23, 0xbb, 0x71, 0x1d, 0xe4, 0x4d, 0x07, 0x99,
	0x70, 0x27, 0x2e, 0xb2, 0xe6, 0x82, 0x51, 0x41, 0x63, 0x02, 0x53, 0x0a, 0xc8, 0xd3, 0xb9, 0x3d,
	0x9d, 0xdb, 0xa6, 0xb4, 0x37, 0x23, 0xa5, 0xfe, 0x71, 0xe0, 0x70, 0xb3, 0x91, 0xfe, 0x2c, 0xa9,
	0xa5, 0xf3, 0x39, 0xf5, 0x94, 0xea, 0x79, 0x42, 0xe5, 0x8e, 0xd1, 0x13, 0xae, 0x58, 0x29, 0xe5,
	0xcb, 0x29, 0xa5, 0xd3, 0x19, 0x06, 0xda, 0xd1, 0x72, 0xd2, 0x14, 0xee, 0x1c, 0xb9, 0xb0, 0xe7,
	0x8b, 0x00, 0x60, 0xfc, 0xab, 0xc1, 0x07, 0x9d, 0x20, 0x98, 0x63, 0x0b, 0x3c, 0xf3, 0x26, 0x94,
	0x1c, 0x40, 0xd6, 0x1d, 0xd7, 0xb5, 0x7d, 0xed, 0xb0, 0xdc, 0x7a, 0x6a, 0xc6, 0xd3, 0x3d, 0x53,
	0xde, 0xad, 0xac, 0x3b, 0x26, 0x5f, 0x03, 0x78, 0x54, 0x0c, 0x47, 0x38, 0xa1, 0x0c, 0xeb, 0x59,
	0x09, 0xd7, 0xcd, 0x20, 0xa0, 0x19, 0x06, 0x34, 0x07, 0x61, 0x40, 0xab, 0xe4, 0x51, 0x71, 0x22,
	0xc1, 0xe4, 0x2b, 0xf0, 0x0f, 0x43, 0x7b, 0x22, 0x90, 0xd5, 0x73, 0x0f, 0x5a, 0x16, 0x3d, 0x2a,
	0xda, 0x3e, 0x96, 0xb4, 0xa0, 0xe4, 0x53, 0x33, 0x14, 0xab, 0x05, 0xd6, 0xf3, 0xfb, 0xda, 0x61,
	0x65, 0x2d, 0x43, 0xbf, 0x96, 0xc1, 0x6a, 0x81, 0x56, 0xd1, 0x51, 0x5f, 0xc6, 0x3f, 0x1a, 0x90,
	0xb5, 0x12, 0xdf, 0xd9, 0x0b, 0x32, 0x84, 0x3d, 0xe7, 0x56, 0xca, 0xeb, 0xda, 0x7e, 0xee, 0xb0,
	0xdc, 0xfa, 0xd6, 0xdc, 0xd8, 0x1e, 0xf3, 0xae, 0x83, 0xb8, 0x88, 0x77, 0x3d, 0xc1, 0x56, 0x56,
	0xc2, 0xa1, 0x3e, 0x85, 0xda, 0x1d, 0x08, 0xa9, 0x42, 0xee, 0x1a, 0x57, 0x92, 0xdc, 0x92, 0xe5,
	0x7f, 0x92, 0xef, 0x60, 0xe7, 0xc6, 0x9e, 0x2d, 0x43, 0x06, 0x3f, 0xdb, 0x2e, 0x01, 0x2b, 0x30,
	0xfa, 0x26, 0x7b, 0xac, 0x19, 0x7f, 0x6a, 0x50, 0x69, 0x8f, 0xc7, 0x3e, 0xc2, 0xc2, 0x5f, 0x97,
	0xc8, 0xc5, 0xb6, 0x2d, 0x7c, 0x06, 0x92, 0xa6, 0xe1, 0x18, 0x99, 0x0c, 0xbf, 0x67, 0xed, 0xfa,
	0xe7, 0xd3, 0x75, 0xa6, 0x73, 0xdb, 0x31, 0xfd, 0x0a, 0x9e, 0x5c, 0x22, 0x73, 0xed, 0x59, 0x7f,
	0x39, 0x1f, 0x21, 0xe3, 0x7e, 0xb5, 0xdc, 0x0b, 0xa8, 0x2d, 0x59, 0xfe, 0xa7, 0x71, 0x02, 0x7b,
	0x3d, 0x14, 0x9d, 0x76, 0x98, 0x68, 0x22, 0x8c, 0xb6, 0x5d, 0x98, 0xbf, 0x34, 0x28, 0x5e, 0x2c,
	0x90, 0xd9, 0x82, 0x32, 0xa2, 0x43, 0x71, 0xc9, 0x91, 0x79, 0xf6, 0x1c, 0x15, 0xab, 0xd1, 0xd9,
	0xd7, 0x2d, 0x6c, 0xce, 0x7f, 0xa3, 0x6c, 0xac, 0xca, 0x8b, 0xce, 0xa4, 0x0d, 0x05, 0x41, 0xaf,
	0xd1, 0xe3, 0x6a, 0xfe, 0x8e, 0x52, 0x78, 0x0f, 0x03, 0x99, 0x03, 0x1f, 0x7d, 0xee, 0x72, 0x61,
	0x29, 0x43, 0xfd, 0x15, 0x94, 0x22, 0x21, 0xf9, 0x08, 0x76, 0xa4, 0x58, 0x15, 0x1b, 0x1c, 0x8c,
	0x3f, 0xb2, 0x50, 0xf8, 0x81, 0xce, 0x5c, 0x67, 0x15, 0x07, 0x68, 0x11, 0x80, 0x7c, 0x09, 0x05,
	0x9c, 0x4c, 0xd0, 0x11, 0x32, 0xc1, 0x4a, 0xeb, 0x45, 0x4a, 0x1a, 0x5d, 0x09, 0xb2, 0x14, 0xd8,
	0x37, 0xb3, 0x1d, 0xe1, 0x52, 0x4f, 0xb5, 0x26, 0xcd, 0xac, 0x2d, 0x41, 0x96, 0x02, 0x93, 0xb7,
	0x50, 0x62, 0xc8, 0xe9, 0x92, 0x39, 0xc8, 0xe5, 0xf5, 0x29, 0xb7, 0x1a, 0x29, 0x96, 0x41, 0xd6,
	0xa6, 0xa5, 0xe0, 0xb2, 0xf0, 0x5b, 0x63, 0xbd, 0x01, 0x7b, 0x71, 0x95, 0x4f, 0x75, 0xa8, 0xac,
	0xe7, 0x25, 0x03, 0xd1, 0xd9, 0x78, 0x03, 0xa4, 0x87, 0x22, 0x24, 0x32, 0xec, 0xfc, 0x7d, 0x8d,
	0x8b, 0xb8, 0xca, 0xc6, 0xb8, 0x32, 0x7e, 0x87, 0x5a, 0x87, 0xa1, 0x2d, 0xf0, 0x3d, 0xc7, 0xc8,
	0xcd, 0x6b, 0xc8, 0xfb, 0x66, 0x6a, 0xd6, 0x5f, 0x3e, 0xd0, 0x45, 0x4b, 0x82, 0x7d, 0xfa, 0x16,
	0xb2, 0x3e, 0x75, 0xe9, 0x5e, 0xdc, 0x4b, 0x82, 0xa5, 0xc0, 0xc6, 0xdf, 0x1a, 0xd4, 0x7b, 0x28,
	0x02, 0xe9, 0x29, 0x3a, 0x2e, 0xf7, 0xc9, 0x55, 0x89, 0xf4, 0xa0, 0x24, 0xc2, 0x69, 0x50, 0xd9,
	0x3c, 0x62, 0xa6, 0x6e, 0x6d, 0x49, 0x07, 0x9e, 0xb0, 0xc0, 0x67, 0xd0, 0xbd, 0x07, 0x26, 0x43,
	0xb5, 0x38, 0x69, 0x93, 0xe8, 0x47, 0x2e, 0x60, 0x37, 0xea, 0x47, 0x0f, 0x2a, 0xc9, 0x12, 0x62,
	0x53, 0xa8, 0x3d, 0x62, 0x0a, 0x1b, 0x0d, 0x28, 0x04, 0x12, 0x52, 0x86, 0xdd, 0xf7, 0xfd, 0xef,
	0xfb, 0x17, 0x57, 0xfd, 0x6a, 0x86, 0x14, 0x21, 0x7f, 0xda, 0xed, 0xff, 0x5c, 0xd5, 0x48, 0x09,
	0x76, 0xda, 0xe7, 0xe7, 0x17, 0x57, 0xd5, 0x6c, 0xe3, 0x73, 0x28, 0xa8, 0xd4, 0x8a, 0x90, 0xef,
	0x5f, 0xf4, 0xbb, 0x01, 0xd0, 0xea, 0xb6, 0x4f, 0x03, 0xe0, 0x95, 0x75, 0x36, 0xe8, 0x56, 0xb3,
	0xad, 0xff, 0x76, 0xa1, 0xd4, 0x09, 0x23, 0x92, 0x0e, 0xec, 0xc8, 0x7d, 0x41, 0x3e, 0x49, 0x49,
	0x29, 0xbe, 0x4d, 0xf4, 0x0f, 0x93, 0xab, 0xa3, 0xed, 0xfb, 0x31, 0x32, 0xe4, 0x04, 0xc8, 0xa5,
	0x3b, 0xf5, 0xd4, 0x8e, 0x54, 0x5b, 0x94, 0x54, 0x93, 0xe0, 0x4b, 0x4b, 0xaf, 0xdf, 0xd9, 0x3c,
	0x0a, 0x6b, 0x64, 0xc8, 0x00, 0xca, 0x3d, 0x14, 0xe1, 0xf6, 0x24, 0xcf, 0xd3, 0xa0, 0xe6, 0x65,
	0x5f, 0xdf, 0x72, 0x87, 0x1b, 0x19, 0xd2, 0x85, 0x9a, 0x85, 0x37, 0xf4, 0x1a, 0xe3, 0x89, 0xdd,
	0xeb, 0xbb, 0x96, 0x50, 0xfe, 0x44, 0xdd, 0xb1, 0x91, 0x21, 0xe7, 0xd1, 0x03, 0x10, 0xfa, 0x38,
	0x48, 0x9b, 0x96, 0xc4, 0x3b, 0xb1, 0xd9, 0xdb, 0x8f, 0x50, 0x7d, 0xe3, 0x7a, 0x71, 0x77, 0x9c,
	0x6c, 0x7e, 0x44, 0xf4, 0x4f, 0x53, 0xc2, 0x24, 0x9e, 0x01, 0x23, 0x43, 0xde, 0x41, 0xd5, 0x9f,
	0xed, 0x84, 0xcb, 0xbb, 0xb1, 0xb7, 0x76, 0xf7, 0x16, 0x0a, 0x3d, 0x14, 0xed, 0xd9, 0x6c, 0x93,
	0x93, 0xa3, 0xad, 0x9f, 0x70, 0x23, 0x43, 0x8e, 0xa1, 0xd2, 0xa1, 0xb3, 0x19, 0x3a, 0xa2, 0x67,
	0xb3, 0x91, 0x3d, 0xc5, 0x4d, 0x1e, 0x37, 0xb2, 0x74, 0x0d, 0xb5, 0xd8, 0x56, 0x93, 0x37, 0x99,
	0x93, 0xa3, 0xf4, 0x29, 0x5d, 0xdb, 0x7f, 0xfa, 0xf6, 0xcb, 0xc1, 0xc8, 0x90, 0xb9, 0x0c, 0xb6,
	0x76, 0x6b, 0x9b, 0xe9, 0xc1, 0x36, 0xae, 0x28, 0xfd, 0xe0, 0xde, 0x35, 0x17, 0xa2, 0x8d, 0x0c,
	0x71, 0x00, 0x6e, 0x37, 0x2d, 0x39, 0x4c, 0x23, 0x74, 0x7d, 0x19, 0x3f, 0xaa, 0xa6, 0x93, 0x2f,
	0x7e, 0x09, 0xd0, 0xcd, 0x6d, 0xff, 0x4a, 0x8f, 0x0a, 0xf2, 0xf7, 0xf5, 0xff, 0x01, 0x00, 0x00,
	0xff, 0xff, 0xf8, 0xca, 0x0f, 0x04, 0x7d, 0x0b, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// CertifierClient is the client API for Certifier service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CertifierClient interface {
	// Returns the cert of the requested CA
	GetCA(ctx context.Context, in *GetCARequest, opts ...grpc.CallOption) (*protos.CACert, error)
	// Signs and adds a new certificate to the store.
	// Returns signed certificate.
	//
	SignAddCertificate(ctx context.Context, in *protos.CSR, opts ...grpc.CallOption) (*protos.Certificate, error)
	// Returns the CertificateInfo for a certificate.
	// Throws NOT_FOUND if the certificate is missing.
	//
	GetIdentity(ctx context.Context, in *protos.Certificate_SN, opts ...grpc.CallOption) (*CertificateInfo, error)
	// Revoke an existing certificate.
	// If the certificate does not exist or is expired, this request is ignored.
	//
	RevokeCertificate(ctx context.Context, in *protos.Certificate_SN, opts ...grpc.CallOption) (*protos.Void, error)
	// Add provided Certificate (AddCertRequest.cert_der) into Certifier table and
	// associates its Serial Number with given Identity (AddCertRequest.id)
	AddCertificate(ctx context.Context, in *AddCertRequest, opts ...grpc.CallOption) (*protos.Void, error)
	// Finds & returns Serial Numbers of all Certificates associated with the
	// given Identity
	FindCertificates(ctx context.Context, in *protos.Identity, opts ...grpc.CallOption) (*SerialNumbers, error)
	// Returns serial numbers of all certificates in the table
	ListCertificates(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*SerialNumbers, error)
	// Returns all registered Certificates
	GetAll(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*CertificateInfoMap, error)
	// cleanup expired certificates
	CollectGarbage(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*protos.Void, error)
	// Get all operator tokens given a username and token
	GetOperatorTokens(ctx context.Context, in *GetOperatorRequest, opts ...grpc.CallOption) (*Operator_TokenList, error)
	// Returns a policy decision given tokens, action based on the request method
	// (read/write), and the requested resource
	GetPolicyDecision(ctx context.Context, in *GetPolicyDecisionRequest, opts ...grpc.CallOption) (*PolicyDecision, error)
	// Creates a new user
	CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*Operator_TokenList, error)
}

type certifierClient struct {
	cc grpc.ClientConnInterface
}

func NewCertifierClient(cc grpc.ClientConnInterface) CertifierClient {
	return &certifierClient{cc}
}

func (c *certifierClient) GetCA(ctx context.Context, in *GetCARequest, opts ...grpc.CallOption) (*protos.CACert, error) {
	out := new(protos.CACert)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/GetCA", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) SignAddCertificate(ctx context.Context, in *protos.CSR, opts ...grpc.CallOption) (*protos.Certificate, error) {
	out := new(protos.Certificate)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/SignAddCertificate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) GetIdentity(ctx context.Context, in *protos.Certificate_SN, opts ...grpc.CallOption) (*CertificateInfo, error) {
	out := new(CertificateInfo)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/GetIdentity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) RevokeCertificate(ctx context.Context, in *protos.Certificate_SN, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/RevokeCertificate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) AddCertificate(ctx context.Context, in *AddCertRequest, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/AddCertificate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) FindCertificates(ctx context.Context, in *protos.Identity, opts ...grpc.CallOption) (*SerialNumbers, error) {
	out := new(SerialNumbers)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/FindCertificates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) ListCertificates(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*SerialNumbers, error) {
	out := new(SerialNumbers)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/ListCertificates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) GetAll(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*CertificateInfoMap, error) {
	out := new(CertificateInfoMap)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/GetAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) CollectGarbage(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/CollectGarbage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) GetOperatorTokens(ctx context.Context, in *GetOperatorRequest, opts ...grpc.CallOption) (*Operator_TokenList, error) {
	out := new(Operator_TokenList)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/GetOperatorTokens", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) GetPolicyDecision(ctx context.Context, in *GetPolicyDecisionRequest, opts ...grpc.CallOption) (*PolicyDecision, error) {
	out := new(PolicyDecision)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/GetPolicyDecision", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*Operator_TokenList, error) {
	out := new(Operator_TokenList)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/CreateUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CertifierServer is the server API for Certifier service.
type CertifierServer interface {
	// Returns the cert of the requested CA
	GetCA(context.Context, *GetCARequest) (*protos.CACert, error)
	// Signs and adds a new certificate to the store.
	// Returns signed certificate.
	//
	SignAddCertificate(context.Context, *protos.CSR) (*protos.Certificate, error)
	// Returns the CertificateInfo for a certificate.
	// Throws NOT_FOUND if the certificate is missing.
	//
	GetIdentity(context.Context, *protos.Certificate_SN) (*CertificateInfo, error)
	// Revoke an existing certificate.
	// If the certificate does not exist or is expired, this request is ignored.
	//
	RevokeCertificate(context.Context, *protos.Certificate_SN) (*protos.Void, error)
	// Add provided Certificate (AddCertRequest.cert_der) into Certifier table and
	// associates its Serial Number with given Identity (AddCertRequest.id)
	AddCertificate(context.Context, *AddCertRequest) (*protos.Void, error)
	// Finds & returns Serial Numbers of all Certificates associated with the
	// given Identity
	FindCertificates(context.Context, *protos.Identity) (*SerialNumbers, error)
	// Returns serial numbers of all certificates in the table
	ListCertificates(context.Context, *protos.Void) (*SerialNumbers, error)
	// Returns all registered Certificates
	GetAll(context.Context, *protos.Void) (*CertificateInfoMap, error)
	// cleanup expired certificates
	CollectGarbage(context.Context, *protos.Void) (*protos.Void, error)
	// Get all operator tokens given a username and token
	GetOperatorTokens(context.Context, *GetOperatorRequest) (*Operator_TokenList, error)
	// Returns a policy decision given tokens, action based on the request method
	// (read/write), and the requested resource
	GetPolicyDecision(context.Context, *GetPolicyDecisionRequest) (*PolicyDecision, error)
	// Creates a new user
	CreateUser(context.Context, *CreateUserRequest) (*Operator_TokenList, error)
}

// UnimplementedCertifierServer can be embedded to have forward compatible implementations.
type UnimplementedCertifierServer struct {
}

func (*UnimplementedCertifierServer) GetCA(ctx context.Context, req *GetCARequest) (*protos.CACert, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCA not implemented")
}
func (*UnimplementedCertifierServer) SignAddCertificate(ctx context.Context, req *protos.CSR) (*protos.Certificate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignAddCertificate not implemented")
}
func (*UnimplementedCertifierServer) GetIdentity(ctx context.Context, req *protos.Certificate_SN) (*CertificateInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIdentity not implemented")
}
func (*UnimplementedCertifierServer) RevokeCertificate(ctx context.Context, req *protos.Certificate_SN) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeCertificate not implemented")
}
func (*UnimplementedCertifierServer) AddCertificate(ctx context.Context, req *AddCertRequest) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCertificate not implemented")
}
func (*UnimplementedCertifierServer) FindCertificates(ctx context.Context, req *protos.Identity) (*SerialNumbers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindCertificates not implemented")
}
func (*UnimplementedCertifierServer) ListCertificates(ctx context.Context, req *protos.Void) (*SerialNumbers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCertificates not implemented")
}
func (*UnimplementedCertifierServer) GetAll(ctx context.Context, req *protos.Void) (*CertificateInfoMap, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAll not implemented")
}
func (*UnimplementedCertifierServer) CollectGarbage(ctx context.Context, req *protos.Void) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CollectGarbage not implemented")
}
func (*UnimplementedCertifierServer) GetOperatorTokens(ctx context.Context, req *GetOperatorRequest) (*Operator_TokenList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOperatorTokens not implemented")
}
func (*UnimplementedCertifierServer) GetPolicyDecision(ctx context.Context, req *GetPolicyDecisionRequest) (*PolicyDecision, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPolicyDecision not implemented")
}
func (*UnimplementedCertifierServer) CreateUser(ctx context.Context, req *CreateUserRequest) (*Operator_TokenList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}

func RegisterCertifierServer(s *grpc.Server, srv CertifierServer) {
	s.RegisterService(&_Certifier_serviceDesc, srv)
}

func _Certifier_GetCA_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCARequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).GetCA(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/GetCA",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).GetCA(ctx, req.(*GetCARequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_SignAddCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.CSR)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).SignAddCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/SignAddCertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).SignAddCertificate(ctx, req.(*protos.CSR))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_GetIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.Certificate_SN)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).GetIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/GetIdentity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).GetIdentity(ctx, req.(*protos.Certificate_SN))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_RevokeCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.Certificate_SN)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).RevokeCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/RevokeCertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).RevokeCertificate(ctx, req.(*protos.Certificate_SN))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_AddCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddCertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).AddCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/AddCertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).AddCertificate(ctx, req.(*AddCertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_FindCertificates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.Identity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).FindCertificates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/FindCertificates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).FindCertificates(ctx, req.(*protos.Identity))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_ListCertificates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).ListCertificates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/ListCertificates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).ListCertificates(ctx, req.(*protos.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_GetAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).GetAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/GetAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).GetAll(ctx, req.(*protos.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_CollectGarbage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).CollectGarbage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/CollectGarbage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).CollectGarbage(ctx, req.(*protos.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_GetOperatorTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOperatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).GetOperatorTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/GetOperatorTokens",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).GetOperatorTokens(ctx, req.(*GetOperatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_GetPolicyDecision_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPolicyDecisionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).GetPolicyDecision(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/GetPolicyDecision",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).GetPolicyDecision(ctx, req.(*GetPolicyDecisionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/CreateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).CreateUser(ctx, req.(*CreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Certifier_serviceDesc = grpc.ServiceDesc{
	ServiceName: "magma.orc8r.certifier.Certifier",
	HandlerType: (*CertifierServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCA",
			Handler:    _Certifier_GetCA_Handler,
		},
		{
			MethodName: "SignAddCertificate",
			Handler:    _Certifier_SignAddCertificate_Handler,
		},
		{
			MethodName: "GetIdentity",
			Handler:    _Certifier_GetIdentity_Handler,
		},
		{
			MethodName: "RevokeCertificate",
			Handler:    _Certifier_RevokeCertificate_Handler,
		},
		{
			MethodName: "AddCertificate",
			Handler:    _Certifier_AddCertificate_Handler,
		},
		{
			MethodName: "FindCertificates",
			Handler:    _Certifier_FindCertificates_Handler,
		},
		{
			MethodName: "ListCertificates",
			Handler:    _Certifier_ListCertificates_Handler,
		},
		{
			MethodName: "GetAll",
			Handler:    _Certifier_GetAll_Handler,
		},
		{
			MethodName: "CollectGarbage",
			Handler:    _Certifier_CollectGarbage_Handler,
		},
		{
			MethodName: "GetOperatorTokens",
			Handler:    _Certifier_GetOperatorTokens_Handler,
		},
		{
			MethodName: "GetPolicyDecision",
			Handler:    _Certifier_GetPolicyDecision_Handler,
		},
		{
			MethodName: "CreateUser",
			Handler:    _Certifier_CreateUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "orc8r/cloud/go/services/certifier/protos/certifier.proto",
}
